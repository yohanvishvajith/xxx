<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error 404</title>
  <style>
    body {
      background-color: white;
      color: white;
      font-family: 'Courier New', monospace;
      padding: 20px;
      line-height: 1.5;
    }
    pre {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
      white-space: pre-wrap;
      margin: 10px 0;
    }
    .code-block {
      margin-bottom: 30px;
    }
    h2 {
      color: white;
      margin-top: 30px;
      border-bottom: 1px solid white;
      padding-bottom: 5px;
    }
  </style>
</head>
<body>
  <pre><code>
    
  <div class="code-block">

 #Inensiy 
# Import libraries
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load image in grayscale
img = cv2.imread('image.jpg', 0)

# Display original image
plt.figure(figsize=(6, 6))
plt.title("Original Image")
plt.imshow(img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 1. Negative Transformation
def negative_transformation(img):
    neg_img = 255 - img
    return neg_img

# Apply and display
neg_img = negative_transformation(img)
plt.figure(figsize=(6, 6))
plt.title("Negative Image")
plt.imshow(neg_img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 2. Log Transformation
def log_transformation(img):
    c = 255 / np.log(1 + np.max(img))
    log_img = c * (np.log(1 + img))
    log_img = np.array(log_img, dtype=np.uint8)
    return log_img

# Apply and display
log_img = log_transformation(img)
plt.figure(figsize=(6, 6))
plt.title("Log Transformed Image")
plt.imshow(log_img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 3. Gamma (Power-law) Transformation
def gamma_transformation(img, gamma=1.0):
    normalized_img = img / 255.0
    gamma_img = np.power(normalized_img, gamma)
    gamma_img = np.uint8(gamma_img * 255)
    return gamma_img

# Apply and display for different gamma values
gammas = [0.5, 1.5, 2.0]
plt.figure(figsize=(18, 6))
for i, g in enumerate(gammas):
    transformed = gamma_transformation(img, gamma=g)
    plt.subplot(1, len(gammas), i+1)
    plt.title(f"Gamma = {g}")
    plt.imshow(transformed, cmap='gray')
    plt.axis('off')
plt.show()

# --------------------------------------------
# 4. Piecewise Linear Transformation
def piecewise_linear_transformation(img, r1, s1, r2, s2):
    def pixel_val(p):
        if p < r1:
            return (s1 / r1) * p
        elif p < r2:
            return ((s2 - s1) / (r2 - r1)) * (p - r1) + s1
        else:
            return ((255 - s2) / (255 - r2)) * (p - r2) + s2

    pixel_val_vec = np.vectorize(pixel_val)
    contrast_stretched = pixel_val_vec(img)
    return np.array(contrast_stretched, dtype=np.uint8)

# Apply and display
r1, s1 = 70, 0
r2, s2 = 140, 255
contrast_img = piecewise_linear_transformation(img, r1, s1, r2, s2)

plt.figure(figsize=(6, 6))
plt.title("Piecewise Linear Transformation")
plt.imshow(contrast_img, cmap='gray')
plt.axis('off')
plt.show()
///////////////////////////////////////////////////////////
#Inensiy 
# Import libraries
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Load image in grayscale
img = cv2.imread('image.jpg', 0)

# Display original image
plt.figure(figsize=(6, 6))
plt.title("Original Image")
plt.imshow(img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 1. Negative Transformation
def negative_transformation(img):
    neg_img = 255 - img
    return neg_img

# Apply and display
neg_img = negative_transformation(img)
plt.figure(figsize=(6, 6))
plt.title("Negative Image")
plt.imshow(neg_img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 2. Log Transformation
def log_transformation(img):
    c = 255 / np.log(1 + np.max(img))
    log_img = c * (np.log(1 + img))
    log_img = np.array(log_img, dtype=np.uint8)
    return log_img

# Apply and display
log_img = log_transformation(img)
plt.figure(figsize=(6, 6))
plt.title("Log Transformed Image")
plt.imshow(log_img, cmap='gray')
plt.axis('off')
plt.show()

# --------------------------------------------
# 3. Gamma (Power-law) Transformation
def gamma_transformation(img, gamma=1.0):
    normalized_img = img / 255.0
    gamma_img = np.power(normalized_img, gamma)
    gamma_img = np.uint8(gamma_img * 255)
    return gamma_img

# Apply and display for different gamma values
gammas = [0.5, 1.5, 2.0]
plt.figure(figsize=(18, 6))
for i, g in enumerate(gammas):
    transformed = gamma_transformation(img, gamma=g)
    plt.subplot(1, len(gammas), i+1)
    plt.title(f"Gamma = {g}")
    plt.imshow(transformed, cmap='gray')
    plt.axis('off')
plt.show()

# --------------------------------------------
# 4. Piecewise Linear Transformation
def piecewise_linear_transformation(img, r1, s1, r2, s2):
    def pixel_val(p):
        if p < r1:
            return (s1 / r1) * p
        elif p < r2:
            return ((s2 - s1) / (r2 - r1)) * (p - r1) + s1
        else:
            return ((255 - s2) / (255 - r2)) * (p - r2) + s2

    pixel_val_vec = np.vectorize(pixel_val)
    contrast_stretched = pixel_val_vec(img)
    return np.array(contrast_stretched, dtype=np.uint8)

# Apply and display
r1, s1 = 70, 0
r2, s2 = 140, 255
contrast_img = piecewise_linear_transformation(img, r1, s1, r2, s2)

plt.figure(figsize=(6, 6))
plt.title("Piecewise Linear Transformation")
plt.imshow(contrast_img, cmap='gray')
plt.axis('off')
plt.show()
///////////////////////////////////////////////////////////
import cv2
from google.colab.patches import cv2_imshow

image = cv2.imread('image.jpg')
cv2_imshow(image)

# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# Save the grayscale image
cv2.imwrite('gray_image.jpg', gray_image)

# Read the image from file
image = cv2.imread('gray_image.jpg')


# Resize the image to 300x200
resized_image = cv2.resize(image, (300, 200))
# Save the resized image
cv2.imwrite('resized_image.jpg', resized_image)


#Rotating an Image
(h, w) = image.shape[:2]
center = (w // 2, h // 2)
matrix = cv2.getRotationMatrix2D(center, 180, 1.0)
rotated_image = cv2.warpAffine(image, matrix, (w, h))
cv2.imwrite('rotated_image.jpg', rotated_image)

#Blurring an Image
blurred_image = cv2.GaussianBlur (image, (15, 15), 0)

#Edge Detection
# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# Apply Canny edge detector
edges = cv2.Canny (gray_image, 100, 200)


# Draw a rectangle
cv2.rectangle(image, (50, 50), (200, 200), (255, 0, 0), 10)
# Add text to the image
cv2.putText(image, 'OpenCV', (60, 40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)


# Apply thresholding

_,thresh_image = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
# Save the thresholded image
cv2.imwrite('threshold_image.jpg', thresh_image)


import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
# Load the image
image = cv2.imread("mage-with-bad-contrast_Q320.jpg", cv2.IMREAD_GRAYSCALE)
#calculate histrogram
histogram = cv2.calcHist([image], [0], None, [256], [0, 256])

#display original image
plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')
# Display the histogram
plt.subplot(1, 2, 2)
plt.plot(histogram)
plt.title('Histogram')
plt.xlabel('Pixel Value')
plt.ylabel('Frequency')
# Show the plots
plt.tight_layout()
plt.show()

#Histogram Equalization in OpenCV
import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
# Load the image in grayscale
image = cv2.imread("mage-with-bad-contrast_Q320.jpg", cv2.IMREAD_GRAYSCALE)
# Apply histogram equalization
equalized_image = cv2.equalizeHist(image)
# Display original and equalized images
print("original Image")
cv2_imshow(image)
print("Equalized Image")
cv2_imshow(equalized_image)
# Calculate histograms
hist_original = cv2.calcHist([image], [0], None, [256], [0, 256])
hist_equalized = cv2.calcHist([equalized_image], [0], None, [256], [0, 256])
# Plot histograms side by side
plt.figure(figsize=(12, 4))
# Original histogram
plt.subplot(1, 2, 1)
plt.plot(hist_original, color='gray')
plt.title("Histogram of Original Image")
plt.xlabel("Pixel value")
plt.ylabel("Frequency")
# Equalized histogram
plt.subplot(1, 2, 2)
plt.plot(hist_equalized, color='black')
plt.title("Histogram of Equalized Image")
plt.xlabel("Pixel value")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()

CLAHE (Contrast Limited Adaptive Histogram Equalization)
img = cv2.imread('QOTql.png', cv2.IMREAD_GRAYSCALE)
assert img is not None, "file could not be read, check with os.path.exists()" cv2_imshow(img);
# create a CLAHE object (Arguments are optional).
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
cl1 = clahe.apply(img)
cv2_imshow(cl1);
Color image Histogram Processing

# Load the image
image = cv2.imread("macaw.jpg",cv2.COLOR_RGB2BGR)
B = image[:,:,0] #blue layer
G = image[:,:,1] #green layer
R = image[:,:,2] #red layer
B_histo= cv2.calcHist ([image], [0], None, [256], [0,256]) G_histo = cv2.calcHist([image], [1], None, [256], [0,256]) R_histo= cv2.calcHist([image], [2], None, [256], [0,256])
#visualizing histograms
plt.subplot(2, 2, 1)
plt.plot(B_histo, 'b')
plt.subplot(2, 2, 2)
plt.plot(G_histo, 'g')
plt.subplot(2, 2, 3)
plt.plot(R_histo, 'r')

# Load the image
image = cv2.imread("macaw_1c.jpg",cv2.COLOR_RGB2BGR)
cv2_imshow(image);

#seperating colour channels
B = image[:,:,0] #blue layer
G= image[:,:,1] #green layer
R = image[:,:,2] #red layer
#equilize each channel seperately
b_equi= cv2.equalizeHist(B)
g_equi= cv2.equalizeHist(G)
r_equi= cv2.equalizeHist(R)
#calculate histograms for each channel seperately
B_histo= cv2.calcHist ([b_equi], [0], None, [256], [0,256]) G_histo= cv2.calcHist([g_equi],[0], None, [256], [0,256]) R_histo= cv2.calcHist ([r_equi], [0], None, [256], [0,256])
#merge thechannels and create new image
equi_im = cv2.merge([b_equi,g_equi,r_equi])
#visualize the equilized channels seperately
plt.imshow(b_equi)
plt.title("b_equi") plt.show() plt.imshow(g_equi) plt.title("g_equi") plt.show() plt.imshow(r_equi) plt.title("r_equi")
plt.show()

#visualize the channel histograms seperately

plt.subplot(2, plt.plot(G_histo,
'g')
plt.subplot(2, 2, 2) plt.plot(R_histo, 'r')
plt.subplot(2, 2, 3)
plt.plot(B_histo, 'b')
#visualize the original and equilized images
cv2_imshow(image);
cv2.imshow(equi_im);
///////////////////////////////

import matplotlib.pyplot as plt
import cv2
import numpy as np
Linear Spatial Filtering
Smoothing Filters
Mean Filter / Averaging Filter

# Read the image
img = cv2.imread('inputimage.png', 0) #0 means grayscale
# Obtain number of rows and columns
m, n= img.shape
 # Develop Averaging filter (3, 3) mask
 mask = np.ones([3, 3], dtype = int)
 mask mask / 9

 # Convolve the 3X3 mask over the image
 img_new = np.zeros([m, n])

 for i in range(1, m-1):
  for j in range(1, n-1):
      temp = img[i-1, j-1]*mask[0, 0]+img[i-1, j]*mask[0, 1]+
      img[i-1, j + 1]*mask [0, 2]+
      img[i, j-1]*mask[1, 0]+ img[i, j]*mask[1, 1]+
      img[i, j + 1]*mask[1, 2]+
      img[i + 1, j-1]*mask[2, 0]+
      img[i + 1, j]*mask[2, 1]+img[i + 1, j + 1]*mask[2, 2]
      img_new[i, j]= temp
img_new = img_new.astype (np. uint8)
cv2.imwrite('Averaging Filtered Image.tif', img_new)

 # Display the original image using matplotlib
 plt.imshow(img, cmap='gray')
 plt.title('Original Image')
 plt.axis('off') # Hide axes for a cleaner look
 plt.show()


 # Display the blurred image using matplotlib
 plt.imshow(img_new, cmap='gray')
plt.title('Averaging Filtered Image')
plt.axis('off') # Hide axes for a cleaner look
plt.show()
////////////////////////////////
Gaussian Filter
↑# Load the image
 image = cv2.imread('PEL-PTE-s5-4-600x800.jpg', cv2.IMREAD_COLOR)

 # Convert from BGR to RGB for correct color display
 image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)


 # Apply Gaussian filter
 kernel_size = (15,15)
 sigma_value = 0
 # Create a figure with two subplots
 fig, axes = plt.subplots(1, 2, figsize=(12, 6))

 # Display the original image
 axes[0].imshow(image_rgb)
 axes[0].set_title("Original Image")
 axes[0].axis("off")

 # Display the Gaussian-blurred image
 axes[1].imshow(gaussian_blur)
 axes[1].set_title("Gaussian Blur")
 axes[1].axis ("off")

 # Show the images
 plt.show()


Sharpening Filters
Laplacian Filter

gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

 # Apply Laplacian filter
 laplacian = cv2.Laplacian(gray_image, cv2.CV_64F)

 # Create a figure with two subplots
 fig, axes = plt.subplots(1, 2, figsize=(12, 6))

 # Display the original image
 axes[0].imshow(image_rgb)
 axes[0].set_title("Original Image")
 axes[0].axis("off")

 # Display the Laplacian filtered image
 axes[1].imshow(laplacian, cmap='gray')
 axes[1].set_title("Laplacian Filter")
 axes[1].axis ("off")

 # Show the images
 plt.show()
////////////////////////
Non-Linear Spatial Filtering
Smoothing Filters
Order Statistics (Non-linear) filter - Median Filter

 # Read the image
 img_noisy1 = cv2.imread('inputimage.png', 0)

 # Obtain the number of rows and columns
 # of the image
 m, n = img_noisy1.shape

 # Traverse the image. For every 3X3 area,
Gaussian Blur
Laplacian Filter
 # find the median of the pixels and
 # replace the center pixel by the median
 img_new1 = np.zeros([m, n]) # This initializes an empty image (img_new) of the same size as the original image to store the filtered result.
 for i in range(1, m-1):

  for j in range(1, n-1):
    temp = [img_noisy1 [i-1, j-1],
    img_noisy1[i-1, j],
    img_noisy1[i-1, j + 1],
    img_noisy1[i, j-1],
    img_noisy1[i, j],
    img_noisy1[i, j + 1],
    img_noisy1[i + 1, j-1],
    img_noisy1[i + 1, j],

i    mg_noisy1[i + 1, j + 1]]

  temp = sorted (temp)

# In a list of 9 sorted elements, the middle

one is the 5th element.

#But Python indexing starts at 0,
    so temp[4] is the 5th element.

    img_new1[i, j]= temp[4]

 img_new1 = img_new1.astype (np.uint8)
 cv2.imwrite('new_median_filtered.png', img_new1)

 # Display the original image using matplotlib
 plt.imshow(img_noisy1, cmap='gray')
 plt.title('Original Image')
 plt.axis('off') # Hide axes for a cleaner look
 plt.show()


 # Display the blurred image using matplotlib
 plt.imshow(img_new1, cmap='gray')
 plt.title('Median Filtered Image')
 plt.axis('off') # Hide axes for a cleaner look
 plt.show()


            /////////////////////////////////////

Morphological Transformations
. Erosion
 import cv2 as cv
 import numpy as np
 from google.colab.patches import cv2_imshow
 img = cv.imread('j.png', cv. IMREAD_GRAYSCALE)
 assert img is not None, "file could not be read, check with os.path.exists()"
 kernel = np.ones((5,5), np. uint8)
 erosion = cv.erode (img, kernel, iterations = 1)
 print("Original Image:")

 cv2_imshow(img)
 print("Eroded Image:")
 cv2_imshow(erosion)

#Dilation

 dilation = cv.dilate(img, kernel, iterations = 1)
 print("Original Image:")
 cv2_imshow(img)
 print("Dilated Image:")
 cv2_imshow(dilation)

Opening

 img_op_input = cv.imread('opening.png', cv. IMREAD_GRAYSCALE)
 assert img is not None, "file could not be read, check with os.path.exists()"
 opening = cv.morphologyEx(img_op_input, cv.MORPH_OPEN, kernel)
 print("Original Image:")
 cv2_imshow(img_op_input)
 print("Opened Image:")
 cv2_imshow(opening)

Closing

 img_cl_input = cv.imread('closing.png', cv.IMREAD_GRAYSCALE)
 assert img is not None, "file could not be read, check with os.path.exists()"
 closing = cv.morphologyEx(img_cl_input, cv.MORPH_CLOSE, kernel)
 print("Original Image:")
 cv2_imshow(img_cl_input)
 print("Closed Image:")
 cv2_imshow(closing)

Morphological Gradient

 gradient = cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)
 print("Original Image:")
 cv2_imshow(img)
 print("Gradiented Image:")
 cv2_imshow(gradient)

Hit or Miss
 import cv2 as cv
 import numpy as np
 from google.colab.patches import cv2_imshow # For displaying in Colab

 # Define input image (small binary image)
 input_image = np.array((

[0, 0, 0, 0, 0, 0, 0, 0],

[0, 255, 255, 255, 0, 0, 0, 255],
 [0, 255, 255, 255, 0, 0, 0, 0],

[0, 255, 255, 255, 0, 255, 0, 0],

[0, 0, 255, 0, 0, 0, 0, 0],

[0, 0, 255, 0, 0, 255, 255, 0],

[0, 255, 0, 255, 0, 0, 255, 0],
 [0, 255, 255, 255, 0, 0, 0, 0]), dtype="uint8")

 # Define kernel for hit-or-miss
 kernel = np.array((
 [0, 1, 0],

[1, -1, 1],
 [0, 1, 0]), dtype="int")

 # Apply Hit-or-Miss operation


 output_image = cv.morphologyEx (input_image, cv.MORPH HITMISS, kernel)

 # Scale up for visibility (e.g., 40x each pixel)
 scale = 40
 input_resized = cv.resize(input_image, (input_image.shape[1]*scale, input_image.shape[0]*scale), interpolation=cv.INTER_NEAREST)
 output_resized = cv.resize(output_image, (output_image.shape[1]*scale, output_image.shape[0]*scale), interpolation=cv.INTER_NEAREST)

 # Display
 print("Input Image:")
 cv2_imshow(input_resized)

 print("Output Image (Hit-or-Miss):")
 cv2_imshow(output_resized)

////////////////////////////////////

Edge Detection - Sobel Edge Detection

 import cv2
 import numpy as np
 import matplotlib.pyplot as plt

 # Load the image
 image_path
=
'Edge Detection.png'
 image = cv2.imread(image_path)

 # Convert to grayscale
 gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

 # Apply Gaussian smoothing (optional)
 blurred_image = cv2.GaussianBlur (gray_image, (3, 3), 0)

 # Sobel operators
 Gx = cv2.Sobel (blurred_image, cv2.CV_64F, 1, 0, ksize=3)
 Gy= cv2.Sobel (blurred_image, cv2.CV_64F, 0, 1, ksize=3)

 # Gradient magnitude
 G = np.sqrt(Gx**2 + Gy**2)

 # Normalize to range 0-255
 Gx = np. uint8 (255* np.abs (Gx) / np.max(Gx))
 Gy = np. uint8 (255* np.abs (Gy) / np.max(Gy))
 G = np. uint8 (255 G/ np.max(G))

 # Display the results
 plt.figure(figsize=(15, 10))

 # Original image
 plt.subplot(2, 2, 1)
 plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
 plt.title('Original Image')
 plt.axis('off')

 # Gradient in x direction
 plt.subplot(2, 2, 2)
 plt.imshow(Gx, cmap='gray')
 plt.title('Gradient in x direction')
 plt.axis('off')

 # Gradient in Y direction
 plt.subplot(2, 2, 3)
 plt.imshow(Gy, cmap='gray')
 plt.title('Gradient in Y direction')
 plt.axis('off')

 # Edge-detected image
 plt.subplot(2, 2, 4)
 plt.imshow(G, cmap='gray')
 plt.title('Sobel Edge Detection')
 plt.axis('off')
 plt.show()

Edge Detection - Canny Edge Detection
 import cv2
 import numpy as np
 import matplotlib.pyplot as plt

 # Load the image
 image_path = 'Edge Detection.png' # Replace with your image path
 image = cv2.imread(image_path, cv2.IMREAD_COLOR)
 gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

 # Apply Gaussian blur to reduce noise
 blurred_image = cv2.GaussianBlur (gray_image, (5, 5), 1.4)

 # Apply Canny edge detector
 edges = cv2.Canny(blurred_image, 100, 200)

 # Display the result
 plt.figure(figsize=(10, 5))

 # Original image
 plt.subplot(1, 2, 1)
 plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
 plt.title('Original Image')
 plt.axis('off')

 # Edge-detected image
 plt.subplot(1, 2, 2)
 plt.imshow(edges, cmap='gray')
 plt.title('Canny Edge Detection')
 plt.axis('off')

 plt.show()

Edge Detection- Laplacian Edge Detection

 import cv2
 import numpy as np
 import matplotlib.pyplot as plt

 # Load the image
 image_path = 'Edge Detection.png' # Replace with your image path
 image
=
cv2.imread(image_path, cv2.IMREAD_COLOR) gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
 # Optional: Apply Gaussian blur to reduce noise
 blurred_image = cv2.GaussianBlur (gray_image, (3, 3), 0)

 # Apply the Laplacian operator
 laplacian = cv2.Laplacian (blurred_image, cv2.CV_64F)

 # Convert the result to 8-bit (0-255) range
 laplacian_abs = cv2.convertScaleAbs (laplacian)

 # Display the result
 plt.figure(figsize=(10, 5))

 # Original image
 plt.subplot(1, 2, 1)
 plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
 plt.title('Original Image')
 plt.axis('off')

 # Laplacian edge-detected image
 plt.subplot(1, 2, 2)
 plt.imshow(laplacian_abs, cmap='gray')
 plt.title('Laplacian Edge Detection')
 plt.axis('off')

 plt.show()

link textEdge Detection-Prewitt Edge Detection
 import cv2
 import numpy as np
 import matplotlib.pyplot as plt

 def prewitt_edge_detection (image):
Laplacian Edge Detection




# Convert the image to grayscale

gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)


# Apply horizontal Prewitt kernel
 kernel_x = np.array([[-1, 0, 1],
[-1, 0, 1],
[-1, 0, 1]])
horizontal_edges
=
cv2.filter2D (gray_image, -1, kernel_x)




# Apply vertical Prewitt kernel
kernel y = np.array([[-1, -1, -1],
[0, 0, 0],

[1, 1, 1]])


vertical_edges = cv2.filter2D (gray_image, -1, kernel_y)
# Ensure both arrays have the same data type

horizontal_edges = np.float32(horizontal_edges)

vertical_edges = np.float32(vertical_edges)


# Compute gradient magnitude




gradient_magnitude = cv2.magnitude (horizontal_edges, vertical_edges)
threshold = 50
# Optional: Apply thresholding to highlight edges
_,edges = cv2.threshold (gradient_magnitude, threshold, 255, cv2.THRESH_BINARY)
return edges
# Read the input image
image = cv2.imread('Edge Detection.png')
# Apply Prewitt edge detection
edges = prewitt_edge_detection(image)
# Plotting both images using subplots
plt.figure(figsize=(10, 5))
# Original Image
plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title('Original Image')
plt.axis('off')
# Detected Edges
plt.subplot(1, 2, 2)
plt.imshow(edges, cmap='gray')
plt.title('Prewitt Edge Detection')
plt.axis('off')
plt.show()

Global Thresholding
 import cv2
 import numpy as np
 import matplotlib.pyplot as plt

 # Load the image
 color_image = cv2.imread('threshold.png', cv2.IMREAD_COLOR)

 # convert to grayscale image
 grayscale_image = cv2.cvtColor(color_image, cv2.COLOR_BGR2GRAY)

 # Manual thresholding
 threshold_value = 128 # Example manual threshold value
_, binary_image = cv2.threshold (grayscale_image, threshold_value, 255, cv2.THRESH_BINARY)


 # Display the original and thresholded images
 plt.figure(figsize=(15, 5))

 plt.subplot(1, 3, 1)
 plt.title('Original Image')
 plt.imshow(color_image, cmap='gray')
 plt.axis('off')

 plt.subplot(1, 3, 2)
 plt.title('Grayscale Image')
 plt.imshow(grayscale_image, cmap='gray')
 plt.axis('off')

 plt.subplot(1, 3, 3)
 plt.title(f'Global Thresholding (T={threshold_value})')
 plt.imshow(binary_image, cmap='gray')
 plt.axis('off')
 plt.show()
Local Thresholding

import cv2
import matplotlib.pyplot as plt
# Load the original color image
color_image = cv2.imread('threshold.png')
# Convert the color image to grayscale
# Apply Adaptive Mean Thresholding 
            gray_image = cv2.cvtColor(color_image, cv2.COLOR_BGR2GRAY)
adaptive_mean = cv2.adaptiveThreshold (gray_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C,CV2.THRESH_BINARY, 11, 2)


 # Apply Adaptive Gaussian Thresholding
adaptive_gaussian = cv2.adaptive Threshold (gray_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,


CV2.THRESH_BINARY, 11, 2)
 # Display the original, grayscale, and thresholded images
 titles = ['Original Image', 'Grayscale Image', 'Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding']
 images = [color_image, gray_image, adaptive_mean, adaptive_gaussian]

 plt.figure(figsize=(15, 10))
 for i in range(4):

    plt.subplot(2, 2, i+1)

    if i == 0:

        plt.imshow(cv2.cvtColor(images[i], cv2.COLOR_BGR2RGB)) # Convert BGR to RGB for displaying correctly with matplotlib

    else:

      plt.imshow(images[i], cmap='gray')


plt.title(titles[i])
plt.xticks([]), plt.yticks([])
plt.show()

    </div>
      


</code></pre>
  <script>
    window.addEventListener('DOMContentLoaded', function() {
      // Copy all code blocks to clipboard
      const codeBlocks = document.querySelectorAll('pre code');
      let allCode = '';
      
      codeBlocks.forEach(block => {
        allCode += block.textContent + '\n\n';
      });
      
      navigator.clipboard.writeText(allCode).catch(function(err) {
        console.error('Clipboard write failed:', err);
      });
    });
  </script>
</body>
</html>
